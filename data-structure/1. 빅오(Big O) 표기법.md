# 1. 빅오(Big O) 표기법

## 왜 필요한가??
코드의 성능을 측정하기 위한 도구가 필요하다.
1. 속도 (시간)
2. 메모리 사용량
3. 가독성

우선 속도 (시간)에 초점을 맞춰보쟈면

1. 컴퓨터마다 다른 시간을 기록한다.
2. 심지어 같은 컴퓨터라도 컨디션에 따라 다른 시간을 기록한다.
3. 너무 빠른 알고리즘의 경우 속도 측정이 쉽지 않다.

### **속도(시간)이 아니라면 어떤 것이 측정의 도구가 될 수 있을까?**

## Operations (연산)
연산의 갯수가 많을 수록, 시간은 늘어나게 된다.

그리고 연산의 정확한 갯수를 세기는 어렵고, 갯수는 그리 중요한 것이 아니니 대략적으로 표현한다.

<br />

~~~ javascript
function addUpTo(n){
    return n * (n + 1) / 2;
}
~~~

의 경우 언제나 연산은 3개이다.

n이 커진다고 해도, 연산 시간의 차이는 크지 않다. 이런 경우, n과 소요시간의 함수가 **상수**인 것 처럼 ( y = 1 ) 그려지기 때문에, 아래와 같이 표현한다. 

### O(1)

<br />

~~~ javascript
function addUpTo(n) {
  let total = 0;
  for (let i = 1; i <= n; i++) {
    total += i;
  }
  return total;
}
~~~

의 경우 연산은 10n개이다.

n이 커질 경우 연산 시간의 차이가 커진다. 이 예시에서는 n과 소요시간의 함수가 **선형함수** ( y = x ) 와 유사하게 그려지기 때문에, 아래와 같이 표현한다.

### O(n)

<br />

~~~ javascript
function printAllPairs(n) {
  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      console.log(i, j);
    }
  }
}
~~~

이 경우는 **for문이 중첩(nested)** 되게 된다. 이로인해 n과 소요시간의 함수가 **지수함수** (y = x<sup>2</sup>) 와 유사하게 그려지기 때문에, 아래와 같이 표현합니다.

### O(n<sup>2</sup>)

## 쉽게 계산하는 방법

항상 맞지는 않지만 대략 맞는 간단한 방법들

1. 사칙연산은 상수이다.
2. 변수 할당은 상수이다.
3. 배열 혹은 객체에 접근하는 것은 상수이다.
4. 루프 (for, while...) 이 있다면 곱하기가 됩니다. 
예를들어, 배열안에 있는 데이터를 루프로 처리할때도 곱하기가 됩니다. 

## 예제

<br />

~~~ javascript
function logAtLeast5(n) {
  for (var i = 1; i <= Math.max(5, n); i++) {
    console.log(i);
  }
}
~~~

이 경우, n=5 이전까지는 상수의 모습을 보이나, n=6 이상부터는 선형함수의 모습을 보인다.

### O(n)

<br />

~~~ javascript
function logAtMost5(n) {
  for (var i = 1; i <= Math.min(5, n); i++) {
    console.log(i);
  }
}
~~~

이 경우 n=5 까지는 선형함수의 모습이나, n=6 이상부터 상수의 모습을 보인다.

### O(1)



### 또 다른 팁

1. 상수는 무시한다.
- O(2n) > O(n)
- O(500) > O(1)
- O(13n<sup>2</sup>) > O(n<sup>2</sup>)

2. 최고차항만 남긴다.
- O(n+10) > O(n)
- O(1000n + 50) > O(n)
- O(n<sup>2</sup>+5n+8) > O(n<sup>2</sup>)

<br />

여태까지 했던 것은 **"시간복잡도"** 에 관한 내용이다.

n (입력) 이 커질때 실행 속도가 어떻게 바뀌는지에 대한 분석이죠.

이제는 공간, 메모리에 관해서 이야기 해보겠습니다.



## 공간 복잡도 (보조 공간 복잡도)

1. 불리언, 숫자, undefined, null 은 상수 공간이다.
2. string 은 O(n) 공간이다.
3. 배열과 객체도 일반적으로 O(n) 이다.

결국 메모리 공간을 얼마나 차지하는지에 관한 내용.

## log 에 관해서,

시간 복잡도가 O(log n) 인 경우가 있을 수 있다.

이런 경우, 그냥 좋다고 생각하면 된다.

O(n) 과 O(1) 사이에 있다고 생각하면 편하다.

O(nlogn) 이 있을 수 있다.

이 경우에는 O(n<sup>2</sup>) 보다 낫고 O(n) 보다 안좋습니다.

해당 수업에서는 이정도의 이해만 있으면 됩니다.

